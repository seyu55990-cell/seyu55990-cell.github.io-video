<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Media Reader - æ™ºèƒ½å¯¹é½ç‰ˆ</title>
<style>
  /* æ‰€æœ‰åŸæœ‰æ ·å¼ä¿æŒä¸å˜ï¼Œåªæ·»åŠ ä»¥ä¸‹æ–°æ ·å¼ */
  
  /* å¯¹é½è°ƒè¯•é¢æ¿ */
  .alignment-panel {
    background: #e8f4fd;
    border: 1px solid #b6d4fe;
    border-radius: 6px;
    padding: 12px;
    margin: 10px 0;
    font-size: 13px;
  }
  
  .alignment-controls {
    display: flex;
    gap: 8px;
    margin-top: 8px;
    flex-wrap: wrap;
  }
  
  .alignment-btn {
    padding: 6px 12px;
    background: #0d6efd;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 12px;
  }
  
  .alignment-btn.secondary {
    background: #6c757d;
  }
  
  .alignment-btn.success {
    background: #198754;
  }
  
  .alignment-btn.warning {
    background: #ffc107;
    color: #000;
  }
  
  /* å•è¯æ—¶é—´æˆ³æ˜¾ç¤º */
  .word-timestamp {
    font-size: 10px;
    color: #6c757d;
    margin-left: 2px;
    font-family: monospace;
  }
  
  /* å¯¹é½æ¨¡å¼æŒ‡ç¤ºå™¨ */
  .alignment-mode {
    font-size: 11px;
    padding: 2px 6px;
    background: #198754;
    color: white;
    border-radius: 10px;
    margin-left: 8px;
  }
</style>
</head>
<body>

<div class="top-bar">
  <div class="left-controls">
    <label class="file-btn">
      ğŸ¬ éŸ³è§†é¢‘
      <input type="file" id="mediaFile" accept="audio/*,video/*" class="hidden-input">
    </label>

    <label class="file-btn">
      ğŸ“„ å­—å¹•
      <input type="file" id="srtFile" accept=".srt,.txt" class="hidden-input">
    </label>

    <div class="media-container">
      <div class="media-type-indicator" id="mediaTypeIndicator">æœªåŠ è½½åª’ä½“</div>
      <video id="mediaPlayer" controls class="media-player audio-mode" preload="metadata">
        <p>æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒ HTML5 è§†é¢‘/éŸ³é¢‘æ’­æ”¾ã€‚</p>
      </video>
    </div>
  </div>

  <div class="right-controls">
    <button id="followBtn" class="follow-btn" title="ç‚¹å‡»æ»šåŠ¨åˆ°å½“å‰æ’­æ”¾ä½ç½®">ğŸ“Œ</button>
  </div>
</div>

<div class="text-area" id="textArea">
  <div class="loading">ä¸Šä¼ éŸ³è§†é¢‘æ–‡ä»¶å’Œå­—å¹•æ–‡ä»¶å¼€å§‹é˜…è¯»</div>
</div>

<script>
// ç­‰å¾…DOMåŠ è½½å®Œæˆ
document.addEventListener('DOMContentLoaded', function() {
  console.log('Media Reader - æ™ºèƒ½å¯¹é½ç‰ˆ åˆå§‹åŒ–...');
  
  // å…¨å±€å˜é‡
  let subtitles = [];
  let currentLineIndex = -1;
  let followMode = false;
  let isVideo = false;
  let alignmentMode = 'smart'; // 'smart', 'speech', 'simple'
  let speechRecognition = null;
  
  // è·å–DOMå…ƒç´ 
  const mediaPlayer = document.getElementById('mediaPlayer');
  const followBtn = document.getElementById('followBtn');
  const textArea = document.getElementById('textArea');
  const mediaFileInput = document.getElementById('mediaFile');
  const srtFileInput = document.getElementById('srtFile');
  const mediaTypeIndicator = document.getElementById('mediaTypeIndicator');
  
  // ==================== æ™ºèƒ½å¯¹é½æ ¸å¿ƒæ¨¡å— ====================
  
  // 1. éŸ³èŠ‚ä¼°ç®—å™¨
  class SyllableEstimator {
    constructor() {
      // å¸¸è§å•è¯éŸ³èŠ‚è¯å…¸
      this.syllableDict = {
        // å•éŸ³èŠ‚
        'the': 1, 'and': 1, 'you': 1, 'that': 1, 'for': 1, 'with': 1, 'this': 1,
        'have': 1, 'from': 1, 'they': 1, 'what': 1, 'your': 1, 'know': 1, 'like': 1,
        
        // åŒéŸ³èŠ‚
        'about': 2, 'people': 2, 'because': 2, 'really': 2, 'something': 2,
        'other': 2, 'should': 2, 'could': 2, 'would': 2, 'think': 2,
        
        // ä¸‰éŸ³èŠ‚
        'beautiful': 3, 'different': 3, 'important': 3, 'actually': 3,
        'probably': 3, 'interesting': 3, 'understand': 3,
        
        // å››éŸ³èŠ‚åŠä»¥ä¸Š
        'everything': 4, 'particularly': 5, 'unfortunately': 6
      };
      
      // éŸ³èŠ‚è§„åˆ™æƒé‡
      this.vowelGroups = /[aeiouy]+/gi;
      this.silentE = /e$/i;
      this.leEnding = /[^aeiou]le$/i;
    }
    
    estimate(word) {
      word = word.toLowerCase().replace(/[^a-z]/g, '');
      if (!word) return 1;
      
      // 1. æŸ¥å­—å…¸
      if (this.syllableDict[word]) {
        return this.syllableDict[word];
      }
      
      // 2. åŸºæœ¬è§„åˆ™è®¡æ•°
      let baseCount = (word.match(this.vowelGroups) || []).length;
      
      // 3. è°ƒæ•´è§„åˆ™
      // 3.1 é™éŸ³e
      if (this.silentE.test(word) && baseCount > 1) {
        baseCount--;
      }
      
      // 3.2 -leç»“å°¾
      if (this.leEnding.test(word) && !word.endsWith('ale') && !word.endsWith('ole')) {
        baseCount++;
      }
      
      // 3.3 å¤åˆè¯
      if (word.includes('-')) {
        const parts = word.split('-');
        return parts.reduce((sum, part) => sum + this.estimate(part), 0);
      }
      
      return Math.max(1, baseCount);
    }
    
    // è®¡ç®—å‘éŸ³å¤æ‚åº¦ï¼ˆ0-1ï¼‰
    complexity(word) {
      word = word.toLowerCase();
      let score = 0;
      
      // å¤æ‚å‘éŸ³æ¨¡å¼
      const complexPatterns = [
        /th/gi, /gh/gi, /ph/gi, /sch/gi, /[xq]/gi,
        /[^aeiouy]{3,}/gi,  // è¿ç»­è¾…éŸ³
        /[aeiouy]{3,}/gi,   // è¿ç»­å…ƒéŸ³
        /tion$/gi, /sion$/gi, /cious$/gi, /tious$/gi,
        /ough/gi, /augh/gi  // ç‰¹æ®Šå‘éŸ³
      ];
      
      complexPatterns.forEach(pattern => {
        if (pattern.test(word)) score += 0.1;
      });
      
      // é•¿åº¦å› ç´ 
      score += Math.min(word.length / 20, 0.3);
      
      return Math.min(score, 1);
    }
  }
  
  // 2. æ™ºèƒ½å¯¹é½å™¨
  class SmartAligner {
    constructor() {
      this.syllableEstimator = new SyllableEstimator();
      this.baseTimePerSyllable = 0.22; // æ¯ä¸ªéŸ³èŠ‚åŸºç¡€æ—¶é—´
      this.punctuationTime = 0.05;
      this.silenceBetweenWords = 0.07;
    }
    
    // ä¸ºå•å¥åˆ†é…å•è¯æ—¶é—´
    alignSentence(sentence, totalDuration, context = {}) {
      const words = this.splitWords(sentence);
      const wordItems = words.filter(w => w.type === 'word');
      
      if (wordItems.length === 0) return [];
      
      // 1. è®¡ç®—æ¯ä¸ªå•è¯çš„åŸºç¡€æƒé‡
      const weights = [];
      let totalWeight = 0;
      
      for (let i = 0; i < words.length; i++) {
        const item = words[i];
        let weight = 0;
        
        if (item.type === 'word') {
          // åŸºäºéŸ³èŠ‚æ•°
          const syllables = this.syllableEstimator.estimate(item.text);
          weight = syllables;
          
          // è€ƒè™‘å‘éŸ³å¤æ‚åº¦
          const complexity = this.syllableEstimator.complexity(item.text);
          weight *= (1 + complexity * 0.4);
          
          // ä¸Šä¸‹æ–‡è°ƒæ•´
          weight = this.adjustWeightByContext(weight, i, words, context);
        } else {
          // æ ‡ç‚¹ç¬¦å·
          weight = 0.1;
          
          // å¥æœ«æ ‡ç‚¹ç¨é•¿
          if (item.text === '.' || item.text === '!' || item.text === '?') {
            weight = 0.15;
          }
        }
        
        weights.push(weight);
        totalWeight += weight;
      }
      
      // 2. åˆ†é…æ—¶é—´ï¼ˆè€ƒè™‘è¯é—´é—´éš”ï¼‰
      const totalSpeechTime = totalDuration - (wordItems.length - 1) * this.silenceBetweenWords;
      let currentTime = 0;
      const result = [];
      
      for (let i = 0; i < words.length; i++) {
        const weight = weights[i];
        const duration = totalSpeechTime * (weight / totalWeight);
        
        const wordInfo = {
          text: words[i].text,
          type: words[i].type,
          start: currentTime,
          end: currentTime + duration,
          duration: duration,
          syllables: words[i].type === 'word' ? this.syllableEstimator.estimate(words[i].text) : 0,
          weight: weight
        };
        
        result.push(wordInfo);
        currentTime += duration + (i < words.length - 1 ? this.silenceBetweenWords : 0);
      }
      
      // 3. å¾®è°ƒï¼šç¡®ä¿ä¸è¶…è¿‡æ€»æ—¶é•¿
      const actualEnd = result[result.length - 1].end;
      if (actualEnd > totalDuration) {
        const scaleFactor = totalDuration / actualEnd;
        let adjustedTime = 0;
        
        for (let i = 0; i < result.length; i++) {
          result[i].duration *= scaleFactor;
          result[i].start = adjustedTime;
          result[i].end = adjustedTime + result[i].duration;
          adjustedTime = result[i].end + (i < result.length - 1 ? this.silenceBetweenWords : 0);
        }
      }
      
      return result;
    }
    
    splitWords(text) {
      const regex = /([\w'-]+|[.,!?;:"'])/g;
      const matches = text.match(regex) || [];
      return matches.map(m => ({
        type: /^[.,!?;:"']$/.test(m) ? 'punctuation' : 'word',
        text: m
      }));
    }
    
    adjustWeightByContext(weight, index, words, context) {
      let adjusted = weight;
      
      // å¥é¦–è¯é€šå¸¸ç¨é•¿
      if (index === 0) adjusted *= 1.08;
      
      // å¥å°¾è¯é€šå¸¸ç¨é•¿
      if (index === words.length - 1) adjusted *= 1.05;
      
      // ç–‘é—®è¯æ›´é•¿
      const questionWords = ['what', 'why', 'how', 'when', 'where', 'who'];
      if (questionWords.includes(words[index].text?.toLowerCase())) {
        adjusted *= 1.12;
      }
      
      // å¼ºè°ƒè¯ï¼ˆå¤§å†™å¼€å¤´ï¼‰æ›´é•¿
      if (/^[A-Z]/.test(words[index].text) && !/^[A-Z]/.test(context.prevWord || '')) {
        adjusted *= 1.1;
      }
      
      // æ•°å­—é€šå¸¸è¾ƒå¿«
      if (/^\d+$/.test(words[index].text)) {
        adjusted *= 0.85;
      }
      
      return adjusted;
    }
  }
  
  // 3. Web Speech API å¯¹é½å™¨ï¼ˆå¯é€‰ï¼‰
  class SpeechAligner {
    constructor() {
      this.recognition = null;
      this.isListening = false;
      this.lastResult = null;
    }
    
    isAvailable() {
      return 'SpeechRecognition' in window || 'webkitSpeechRecognition' in window;
    }
    
    startListening(audioElement, subtitles) {
      if (!this.isAvailable()) {
        console.warn('æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³è¯†åˆ«');
        return false;
      }
      
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      this.recognition = new SpeechRecognition();
      
      this.recognition.continuous = true;
      this.recognition.interimResults = true;
      this.recognition.lang = 'en-US'; // é»˜è®¤è‹±è¯­
      
      this.recognition.onresult = (event) => {
        const result = event.results[event.resultIndex];
        this.lastResult = {
          transcript: result[0].transcript,
          confidence: result[0].confidence,
          isFinal: result.isFinal
        };
        
        console.log('è¯­éŸ³è¯†åˆ«:', this.lastResult);
        
        // å°è¯•ä¸å­—å¹•å¯¹é½ï¼ˆç®€åŒ–ç‰ˆï¼‰
        this.tryAlignWithSubtitles(subtitles);
      };
      
      this.recognition.onerror = (event) => {
        console.error('è¯­éŸ³è¯†åˆ«é”™è¯¯:', event.error);
      };
      
      try {
        this.recognition.start();
        this.isListening = true;
        return true;
      } catch (error) {
        console.error('æ— æ³•å¯åŠ¨è¯­éŸ³è¯†åˆ«:', error);
        return false;
      }
    }
    
    stopListening() {
      if (this.recognition && this.isListening) {
        this.recognition.stop();
        this.isListening = false;
      }
    }
    
    tryAlignWithSubtitles(subtitles) {
      // ç®€åŒ–çš„å¯¹é½é€»è¾‘ï¼ˆå®é™…éœ€è¦æ›´å¤æ‚çš„ç®—æ³•ï¼‰
      if (!this.lastResult || !this.lastResult.transcript) return;
      
      const currentTranscript = this.lastResult.transcript.toLowerCase();
      
      // åœ¨æ‰€æœ‰å­—å¹•ä¸­æœç´¢åŒ¹é…
      for (const sub of subtitles) {
        const subText = sub.text.toLowerCase();
        if (currentTranscript.includes(subText.substring(0, 20)) || 
            subText.includes(currentTranscript.substring(0, 20))) {
          console.log('æ‰¾åˆ°åŒ¹é…å­—å¹•:', sub.text);
          // è¿™é‡Œå¯ä»¥è§¦å‘å¯¹é½è°ƒæ•´
          break;
        }
      }
    }
  }
  
  // åˆå§‹åŒ–å¯¹é½å™¨
  const smartAligner = new SmartAligner();
  const speechAligner = new SpeechAligner();
  
  // ==================== ä¿®æ”¹åŸæœ‰å‡½æ•° ====================
  
  // å¢å¼ºçš„å­—å¹•è§£æå‡½æ•°
  function parseAndAlignSRT(text, audioDuration) {
    const rawSubs = parseSRT(text);
    
    return rawSubs.map((sub, index) => {
      // ä½¿ç”¨æ™ºèƒ½å¯¹é½åˆ†é…å•è¯æ—¶é—´
      const alignedWords = smartAligner.alignSentence(
        sub.text,
        sub.duration,
        {
          prevWord: index > 0 ? rawSubs[index-1].text : '',
          nextWord: index < rawSubs.length-1 ? rawSubs[index+1].text : '',
          audioDuration: audioDuration
        }
      );
      
      // å°†æ—¶é—´æˆ³æ·»åŠ åˆ°å•è¯å¯¹è±¡
      const wordsWithTiming = sub.words.map((word, wordIndex) => {
        const aligned = alignedWords[wordIndex];
        return {
          ...word,
          startTime: aligned ? aligned.start + sub.start : 0,
          endTime: aligned ? aligned.end + sub.start : 0,
          duration: aligned ? aligned.duration : 0,
          syllables: aligned ? aligned.syllables : 0,
          weight: aligned ? aligned.weight : 0
        };
      });
      
      return {
        ...sub,
        words: wordsWithTiming,
        alignedWords: alignedWords
      };
    });
  }
  
  // æ”¹è¿›çš„é«˜äº®å‡½æ•°
  function updateHighlight() {
    const t = mediaPlayer.currentTime;
    let newLineIndex = -1;
    let currentWordIndex = -1;
    
    // 1. æŸ¥æ‰¾å½“å‰å­—å¹•è¡Œ
    for (let i = 0; i < subtitles.length; i++) {
      const sub = subtitles[i];
      if (t >= sub.start && t < sub.end) {
        newLineIndex = i;
        
        // 2. æŸ¥æ‰¾å½“å‰å•è¯ï¼ˆå¦‚æœæœ‰ç²¾ç¡®æ—¶é—´æˆ³ï¼‰
        if (sub.words && sub.words[0] && sub.words[0].startTime !== undefined) {
          for (let j = 0; j < sub.words.length; j++) {
            const word = sub.words[j];
            if (word.startTime !== undefined && word.endTime !== undefined) {
              if (t >= word.startTime && t < word.endTime) {
                currentWordIndex = j;
                break;
              }
            }
          }
        }
        
        // 3. å¦‚æœæ²¡æœ‰æ‰¾åˆ°ç²¾ç¡®åŒ¹é…ï¼Œä½¿ç”¨æ™ºèƒ½å›é€€
        if (currentWordIndex === -1) {
          const elapsed = t - sub.start;
          const progress = elapsed / sub.duration;
          
          // åŸºäºæƒé‡çš„è¿›åº¦è®¡ç®—
          let accumulated = 0;
          const wordItems = sub.words.filter(w => w.type === 'word');
          
          if (wordItems.length > 0 && sub.alignedWords) {
            for (let k = 0; k < sub.alignedWords.length; k++) {
              if (sub.alignedWords[k].type === 'word') {
                const wordWeight = sub.alignedWords[k].weight || 1;
                const totalWeight = sub.alignedWords.reduce((sum, w) => sum + (w.weight || 1), 0);
                const weightProgress = wordWeight / totalWeight;
                
                accumulated += weightProgress;
                if (progress <= accumulated) {
                  // æ‰¾åˆ°å¯¹åº”çš„åŸå§‹ç´¢å¼•
                  let originalIndex = 0;
                  let wordCount = 0;
                  for (let l = 0; l < sub.words.length; l++) {
                    if (sub.words[l].type === 'word') {
                      if (wordCount === k) {
                        originalIndex = l;
                        break;
                      }
                      wordCount++;
                    }
                  }
                  currentWordIndex = originalIndex;
                  break;
                }
              }
            }
          }
        }
        
        break;
      }
    }
    
    // 4. æ›´æ–°è¡Œé«˜äº®
    if (newLineIndex !== currentLineIndex) {
      if (currentLineIndex !== -1) {
        const oldLine = document.getElementById(`line-${currentLineIndex}`);
        if (oldLine) oldLine.classList.remove('active-line');
      }
      
      if (newLineIndex !== -1) {
        const newLine = document.getElementById(`line-${newLineIndex}`);
        if (newLine) {
          newLine.classList.add('active-line');
          if (followMode) scrollToCurrentLine();
        }
      }
      
      currentLineIndex = newLineIndex;
    }
    
    // 5. æ›´æ–°å•è¯é«˜äº®
    document.querySelectorAll('.word.current').forEach(el => {
      el.classList.remove('current');
    });
    
    if (currentLineIndex !== -1 && currentWordIndex !== -1) {
      const wordEl = document.getElementById(`word-${currentLineIndex}-${currentWordIndex}`);
      if (wordEl) {
        wordEl.classList.add('current');
        
        // å¯é€‰ï¼šæ°´å¹³æ»šåŠ¨ä½¿å½“å‰å•è¯å±…ä¸­
        if (followMode) {
          const lineEl = document.getElementById(`line-${currentLineIndex}`);
          if (lineEl && wordEl.offsetLeft) {
            const scrollLeft = wordEl.offsetLeft - textArea.clientWidth / 3;
            textArea.scrollLeft = Math.max(0, scrollLeft);
          }
        }
      }
    }
  }
  
  // å¢å¼ºçš„æ¸²æŸ“å‡½æ•°ï¼ˆæ˜¾ç¤ºæ—¶é—´æˆ³ï¼‰
  function renderText() {
    console.log('æ¸²æŸ“æ–‡æœ¬...', subtitles.length);
    
    if (subtitles.length === 0) {
      textArea.innerHTML = '<div class="loading">ä¸Šä¼ éŸ³è§†é¢‘æ–‡ä»¶å’Œå­—å¹•æ–‡ä»¶å¼€å§‹é˜…è¯»</div>';
      return;
    }
    
    let html = '';
    subtitles.forEach((sub, i) => {
      html += `<div class="line" id="line-${i}">`;
      sub.words.forEach((w, j) => {
        const timeInfo = w.startTime !== undefined ? 
          `<span class="word-timestamp" title="${w.startTime.toFixed(2)}-${w.endTime.toFixed(2)}s">` +
          `${w.syllables || '?'}éŸ³</span>` : '';
        
        if (w.type === 'word') {
          html += `<span class="word" id="word-${i}-${j}">${w.text}${timeInfo} </span>`;
        } else {
          html += `<span class="punctuation">${w.text} </span>`;
        }
      });
      html += '</div>';
    });
    
    textArea.innerHTML = html;
    console.log('æ–‡æœ¬æ¸²æŸ“å®Œæˆ');
  }
  
  // ==================== ä¿®æ”¹äº‹ä»¶å¤„ç† ====================
  
  // ä¿®æ”¹å­—å¹•ä¸Šä¼ äº‹ä»¶
  srtFileInput.addEventListener('change', function(e) {
    const file = e.target.files[0];
    if (!file) return;
    
    console.log('å­—å¹•æ–‡ä»¶å·²é€‰æ‹©:', file.name);
    const reader = new FileReader();
    
    reader.onload = function() {
      console.log('å¼€å§‹è§£æå­—å¹•æ–‡ä»¶å†…å®¹...');
      
      // ä½¿ç”¨å¢å¼ºç‰ˆè§£æ
      const audioDuration = mediaPlayer.duration || 0;
      subtitles = parseAndAlignSRT(reader.result, audioDuration);
      
      if (subtitles.length === 0) {
        alert('æ— æ³•è§£æå­—å¹•æ–‡ä»¶ï¼Œè¯·æ£€æŸ¥æ ¼å¼æ˜¯å¦ä¸ºSRT');
        return;
      }
      
      // å¦‚æœæœ‰éŸ³é¢‘/è§†é¢‘ï¼Œä¿®æ­£æ•´ä½“æ—¶é—´æˆ³
      if (mediaPlayer.duration && mediaPlayer.duration > 0) {
        subtitles = fixTimestamps(subtitles, mediaPlayer.duration);
        
        // é‡æ–°è®¡ç®—å•è¯çº§æ—¶é—´ï¼ˆåŸºäºä¿®æ­£åçš„æ—¶é—´ï¼‰
        subtitles = subtitles.map((sub, index) => {
          const alignedWords = smartAligner.alignSentence(
            sub.text,
            sub.duration,
            {
              prevWord: index > 0 ? subtitles[index-1].text : '',
              audioDuration: mediaPlayer.duration
            }
          );
          
          const wordsWithTiming = sub.words.map((word, wordIndex) => {
            const aligned = alignedWords[wordIndex];
            return {
              ...word,
              startTime: aligned ? aligned.start + sub.start : 0,
              endTime: aligned ? aligned.end + sub.start : 0,
              duration: aligned ? aligned.duration : 0,
              syllables: aligned ? aligned.syllables : 0
            };
          });
          
          return {
            ...sub,
            words: wordsWithTiming,
            alignedWords: alignedWords
          };
        });
      }
      
      renderText();
      
      // æ˜¾ç¤ºå¯¹é½ä¿¡æ¯é¢æ¿
      showAlignmentInfo();
    };
    
    reader.readAsText(file);
  });
  
  // æ·»åŠ å¯¹é½æ§åˆ¶é¢æ¿
  function showAlignmentInfo() {
    // ç§»é™¤æ—§çš„é¢æ¿
    const oldPanel = document.querySelector('.alignment-panel');
    if (oldPanel) oldPanel.remove();
    
    const panel = document.createElement('div');
    panel.className = 'alignment-panel';
    
    const wordCount = subtitles.reduce((sum, sub) => sum + sub.words.filter(w => w.type === 'word').length, 0);
    const syllableCount = subtitles.reduce((sum, sub) => sum + sub.words.reduce((s, w) => s + (w.syllables || 0), 0), 0);
    
    panel.innerHTML = `
      <div style="margin-bottom: 8px;">
        <strong>ğŸ” æ™ºèƒ½å¯¹é½ä¿¡æ¯</strong>
        <span class="alignment-mode">${alignmentMode.toUpperCase()}</span>
      </div>
      <div style="font-size: 12px; color: #666;">
        å­—å¹•: ${subtitles.length} æ¡ | å•è¯: ${wordCount} ä¸ª | æ€»éŸ³èŠ‚: ${syllableCount} ä¸ª
        <br>å¯¹é½æ¨¡å¼: ${getAlignmentModeName()}
      </div>
    `;
    
    const controls = document.createElement('div');
    controls.className = 'alignment-controls';
    
    // æ¨¡å¼åˆ‡æ¢æŒ‰é’®
    const modes = [
      { id: 'smart', label: 'æ™ºèƒ½éŸ³èŠ‚å¯¹é½', desc: 'åŸºäºéŸ³èŠ‚æ•°åˆ†é…æ—¶é—´' },
      { id: 'simple', label: 'ç®€å•å‡åŒ€å¯¹é½', desc: 'æ¯ä¸ªå•è¯æ—¶é—´ç›¸ç­‰' },
      { id: 'speech', label: 'è¯­éŸ³è¯†åˆ«å¯¹é½', desc: 'å®éªŒåŠŸèƒ½ï¼Œéœ€è¦éº¦å…‹é£æƒé™' }
    ];
    
    modes.forEach(mode => {
      const btn = document.createElement('button');
      btn.className = `alignment-btn ${mode.id === alignmentMode ? 'success' : 'secondary'}`;
      btn.textContent = mode.label;
      btn.title = mode.desc;
      
      btn.onclick = () => {
        setAlignmentMode(mode.id);
        panel.remove();
        showAlignmentInfo();
      };
      
      controls.appendChild(btn);
    });
    
    // æ‰‹åŠ¨æ ¡å‡†æŒ‰é’®
    const calibrateBtn = document.createElement('button');
    calibrateBtn.className = 'alignment-btn warning';
    calibrateBtn.textContent = 'æ‰‹åŠ¨æ ¡å‡†å½“å‰å¥';
    calibrateBtn.onclick = startManualCalibration;
    controls.appendChild(calibrateBtn);
    
    panel.appendChild(controls);
    document.querySelector('.media-container').appendChild(panel);
  }
  
  function setAlignmentMode(mode) {
    alignmentMode = mode;
    
    if (mode === 'speech') {
      if (speechAligner.isAvailable()) {
        const started = speechAligner.startListening(mediaPlayer, subtitles);
        if (!started) {
          alignmentMode = 'smart';
          alert('æ— æ³•å¯åŠ¨è¯­éŸ³è¯†åˆ«ï¼Œå¯èƒ½ç¼ºå°‘éº¦å…‹é£æƒé™æˆ–æµè§ˆå™¨ä¸æ”¯æŒ');
        }
      } else {
        alignmentMode = 'smart';
        alert('æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³è¯†åˆ«åŠŸèƒ½');
      }
    } else if (mode !== 'speech' && speechAligner.isListening) {
      speechAligner.stopListening();
    }
    
    // é‡æ–°æ¸²æŸ“ä»¥æ›´æ–°æ˜¾ç¤º
    renderText();
  }
  
  function getAlignmentModeName() {
    switch(alignmentMode) {
      case 'smart': return 'æ™ºèƒ½éŸ³èŠ‚å¯¹é½ï¼ˆæ¨èï¼‰';
      case 'simple': return 'ç®€å•å‡åŒ€å¯¹é½';
      case 'speech': return 'è¯­éŸ³è¯†åˆ«å¯¹é½ï¼ˆå®éªŒæ€§ï¼‰';
      default: return 'æœªçŸ¥æ¨¡å¼';
    }
  }
  
  function startManualCalibration() {
    if (currentLineIndex === -1) {
      alert('è¯·å…ˆæ’­æ”¾éŸ³é¢‘ï¼Œè®©é«˜äº®å®šä½åˆ°éœ€è¦æ ¡å‡†çš„å¥å­');
      return;
    }
    
    const currentSub = subtitles[currentLineIndex];
    const wordTexts = currentSub.words.filter(w => w.type === 'word').map(w => w.text);
    
    if (wordTexts.length === 0) {
      alert('å½“å‰å¥å­æ²¡æœ‰å¯æ ¡å‡†çš„å•è¯');
      return;
    }
    
    const userInput = prompt(
      `æ ¡å‡†å¥å­: "${currentSub.text}"\n\n` +
      `å½“å‰å•è¯é¡ºåº: ${wordTexts.join(', ')}\n\n` +
      `è¯·è¾“å…¥æ¯ä¸ªå•è¯çš„æŒç»­æ—¶é—´ï¼ˆç§’ï¼‰ï¼Œç”¨é€—å·åˆ†éš”ï¼š\n` +
      `ä¾‹å¦‚: 0.3, 0.4, 0.5, 0.3`,
      currentSub.words.filter(w => w.type === 'word')
        .map(w => w.duration?.toFixed(2) || '0.3')
        .join(', ')
    );
    
    if (userInput) {
      try {
        const durations = userInput.split(',').map(d => parseFloat(d.trim()));
        const wordItems = currentSub.words.filter(w => w.type === 'word');
        
        if (durations.length !== wordItems.length) {
          throw new Error(`è¾“å…¥äº† ${durations.length} ä¸ªæ—¶é—´ï¼Œä½†å¥å­æœ‰ ${wordItems.length} ä¸ªå•è¯`);
        }
        
        // åº”ç”¨æ ¡å‡†
        let currentTime = currentSub.start;
        let wordIndex = 0;
        
        for (let i = 0; i < currentSub.words.length; i++) {
          if (currentSub.words[i].type === 'word') {
            currentSub.words[i].startTime = currentTime;
            currentSub.words[i].endTime = currentTime + durations[wordIndex];
            currentSub.words[i].duration = durations[wordIndex];
            currentTime += durations[wordIndex];
            wordIndex++;
          } else {
            // æ ‡ç‚¹ï¼šå›ºå®šçŸ­æ—¶é—´
            currentSub.words[i].startTime = currentTime;
            currentSub.words[i].endTime = currentTime + 0.05;
            currentSub.words[i].duration = 0.05;
            currentTime += 0.05;
          }
        }
        
        renderText();
        alert('æ ¡å‡†å®Œæˆï¼å½“å‰å¥å­çš„å•è¯æ—¶é—´å·²æ›´æ–°ã€‚');
      } catch (error) {
        alert(`æ ¡å‡†å¤±è´¥: ${error.message}`);
      }
    }
  }
  
  // ==================== åŸæœ‰çš„å…¶ä»–å‡½æ•°ä¿æŒä¸å˜ ====================
  
  // è§£ææ—¶é—´å‡½æ•°
  function parseTime(h, m, s, ms) {
    return parseInt(h) * 3600 + parseInt(m) * 60 + parseInt(s) + parseInt(ms || 0) / 1000;
  }

  // è§£æSRTæ–‡ä»¶ï¼ˆåŸºç¡€ç‰ˆï¼‰
  function parseSRT(text) {
    console.log('å¼€å§‹è§£æSRTæ–‡ä»¶...');
    const lines = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n').split('\n');
    const result = [];
    let i = 0;
    
    while (i < lines.length) {
      while (i < lines.length && lines[i].trim() === '') i++;
      if (i >= lines.length) break;
      
      const indexLine = lines[i].trim();
      if (!/^\d+$/.test(indexLine)) {
        i++;
        continue;
      }
      i++;
      
      if (i >= lines.length) break;
      
      const timeLine = lines[i];
      let timeMatch = timeLine.match(/(\d{2}):(\d{2}):(\d{2})[,.](\d{3})\s*-->\s*(\d{2}):(\d{2}):(\d{2})[,.](\d{3})/);
      
      if (!timeMatch) {
        timeMatch = timeLine.match(/(\d{2}):(\d{2}):(\d{2})\.(\d{3})\s*-->\s*(\d{2}):(\d{2}):(\d{2})\.(\d{3})/);
      }
      
      if (!timeMatch) {
        timeMatch = timeLine.match(/(\d{2}):(\d{2}):(\d{2})\s*-->\s*(\d{2}):(\d{2}):(\d{2})/);
        if (timeMatch) {
          timeMatch[4] = '000';
          timeMatch[8] = '000';
        }
      }
      
      if (!timeMatch) {
        console.warn('æ— æ³•è§£ææ—¶é—´è¡Œ:', timeLine);
        i++;
        continue;
      }
      
      const start = parseTime(timeMatch[1], timeMatch[2], timeMatch[3], timeMatch[4]);
      const end = parseTime(timeMatch[5], timeMatch[6], timeMatch[7], timeMatch[8]);
      i++;
      
      if (i >= lines.length) break;
      
      const textLines = [];
      while (i < lines.length && lines[i].trim() !== '' && !/^\d+$/.test(lines[i].trim())) {
        textLines.push(lines[i].trim());
        i++;
      }
      
      const text = textLines.join(' ');
      const words = splitIntoWords(text);
      
      if (words.length > 0) {
        result.push({
          index: parseInt(indexLine),
          start: start,
          end: end,
          text: text,
          words: words,
          duration: end - start
        });
      }
    }
    
    console.log(`è§£æå®Œæˆï¼Œå…± ${result.length} æ¡å­—å¹•`);
    return result;
  }

  // åˆ†å‰²æ–‡æœ¬ä¸ºå•è¯
  function splitIntoWords(text) {
    const regex = /([\w'-]+|[.,!?;:"'])/g;
    const matches = text.match(regex) || [];
    return matches.map(m => 
      /^[.,!?;:"']$/.test(m) ? { type: 'punctuation', text: m } : { type: 'word', text: m }
    );
  }

  // ä¿®æ­£æ—¶é—´æˆ³
  function fixTimestamps(subs, dur) {
    if (subs.length === 0) return subs;
    
    const last = subs[subs.length - 1].end;
    const needsFix = last > dur * 1.5 || subs[0].start > 3600;
    
    if (!needsFix) return subs;
    
    const first = subs[0].start;
    const hourOffset = Math.floor(first / 3600) * 3600;
    
    if (hourOffset > 0) {
      const testStart = subs[0].start - hourOffset;
      const testEnd = subs[subs.length - 1].end - hourOffset;
      
      if (testEnd <= dur * 1.1 && testStart >= 0) {
        return subs.map(s => ({
          ...s,
          start: Math.max(0, s.start - hourOffset),
          end: Math.max(0, s.end - hourOffset)
        }));
      }
    }
    
    const totalWords = subs.reduce((sum, s) => sum + s.words.filter(w => w.type === 'word').length, 0);
    const avgWordDur = dur / totalWords;
    let currentTime = 0;
    
    return subs.map(s => {
      const wc = s.words.filter(w => w.type === 'word').length;
      const durWord = wc * avgWordDur;
      const newSub = {
        ...s,
        start: currentTime,
        end: currentTime + durWord
      };
      currentTime += durWord;
      return newSub;
    });
  }

  // æ»šåŠ¨åˆ°å½“å‰è¡Œ
  function scrollToCurrentLine() {
    if (currentLineIndex === -1) return;
    
    const line = document.getElementById(`line-${currentLineIndex}`);
    if (!line) return;
    
    textArea.scrollTop = line.offsetTop - textArea.clientHeight / 2 + line.offsetHeight / 2;
  }

  // å…¶ä»–åŸæœ‰å‡½æ•°ï¼ˆmediaFileInputäº‹ä»¶ã€showErrorPanelã€detectVideoEncodingç­‰ï¼‰
  // ä¿æŒä¸å˜ï¼Œæ­¤å¤„çœç•¥ä»¥èŠ‚çœç¯‡å¹…...
  
  // ==================== åˆå§‹åŒ– ====================
  
  // åŸæœ‰çš„åˆå§‹åŒ–ä»£ç ä¿æŒä¸å˜...
  // åªæ˜¯æ›¿æ¢äº†srtFileInputäº‹ä»¶å¤„ç†å’Œé«˜äº®å‡½æ•°
  
  console.log('Media Reader - æ™ºèƒ½å¯¹é½ç‰ˆ åˆå§‹åŒ–å®Œæˆ');
});
</script>

</body>
</html>